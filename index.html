<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Маникюр: эффекты + прогресс загрузки модели</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
  <style>
    :root { --bg:#0f1220; --card:rgba(30,40,80,.95); --radius:14px; --accent:#7ae0ff; --muted:#8f9acb; --shadow:0 40px 100px -10px rgba(0,0,0,.6); }
    *{box-sizing:border-box;}
    body{ margin:0; font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif; background:var(--bg); color:#eef2fc; }
    .layout{ max-width:1200px; margin:auto; padding:14px; display:grid; grid-template-columns:2fr 1fr; gap:18px; }
    @media (max-width:1000px){ .layout{ grid-template-columns:1fr; } }
    .card{ background:var(--card); border-radius:var(--radius); padding:18px; position:relative; box-shadow:var(--shadow); }
    h1{ margin:0; font-size:1.6rem; font-weight:600; }
    .video-wrapper{ position:relative; border-radius:12px; overflow:hidden; background:#0b0f1e; aspect-ratio:4/3; margin-top:8px; margin-bottom:12px; }
    video,canvas{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; border-radius:12px; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:10px; }
    .form-group{ display:flex; flex-direction:column; gap:4px; flex:1; min-width:140px; }
    label{ font-size:12px; margin-bottom:2px; text-transform:uppercase; letter-spacing:.5px; }
    select,input[type=color],input[type=range]{ padding:8px 10px; border-radius:8px; border:none; background:rgba(255,255,255,.06); color:#eef2fc; font-size:14px; outline:none; appearance:none; }
    input[type=range]{ width:100%; }
    .btn{ padding:10px 16px; border:none; border-radius:10px; cursor:pointer; font-weight:600; display:inline-flex; align-items:center; gap:6px; background:linear-gradient(135deg,#4da3ff,#7ae0ff); color:#0f1220; }
    .btn.outline{ background:transparent; border:2px solid var(--accent); color:var(--accent); }
    .badge{ background:rgba(122,224,255,.15); padding:6px 14px; border-radius:999px; font-size:13px; display:inline-block; font-weight:600; }
    .controls{ display:flex; gap:12px; flex-wrap:wrap; margin-top:6px; }
    .downloads{ margin-top:10px; display:flex; flex-direction:column; gap:6px; font-size:14px; }
    .effect-box{ background:rgba(255,255,255,.04); border-radius:10px; padding:12px; margin-top:8px; }
    .small{ font-size:13px; color:var(--muted); }
    .divider{ height:1px; background:rgba(255,255,255,.08); margin:12px 0; }
    .toggles{ display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .checkbox-wrapper{ display:inline-flex; align-items:center; gap:6px; font-size:13px; background:rgba(255,255,255,.05); padding:6px 10px; border-radius:8px; }
    .checkbox-wrapper input{ margin:0; accent-color:#7ae0ff; width:16px; height:16px; }

    /* Loader */
    #loader{ position:fixed; inset:0; background:#0b0f1ee6; display:grid; place-items:center; z-index:9999; }
    #loader .box{ width:min(440px,92vw); background:var(--card); border-radius:16px; padding:16px; box-shadow:var(--shadow); }
    #loader .title{ font:600 16px system-ui; margin-bottom:8px; color:#eef2fc; display:flex; justify-content:space-between; }
    #loader .bar{ height:10px; background:rgba(255,255,255,.15); border-radius:999px; overflow:hidden; }
    #loader .fill{ height:100%; width:0%; background:linear-gradient(90deg,#4da3ff,#7ae0ff); }
    #loader .stage{ margin-top:8px; color:#8f9acb; font:13px system-ui; display:flex; justify-content:space-between; }
    #loader .hint{ margin-top:8px; color:#8f9acb; font:12px system-ui; }
    #error{ display:none; background:#2b1938; border:1px solid #ff7ab3; color:#ffd6e8; padding:10px; border-radius:8px; margin-top:10px; font-size:13px; }
  </style>
</head>
<body>
  <!-- LOADER -->
  <div id="loader">
    <div class="box">
      <div class="title">Загрузка… <span id="loader_pct">0%</span></div>
      <div class="bar"><div id="loader_bar" class="fill"></div></div>
      <div class="stage"><span id="loader_stage">Инициализация</span><span id="loader_sub">—</span></div>
      <div class="hint">Если долго висит на 0–10% — проверь интернет. Для камеры нужен HTTPS или http://localhost.</div>
      <div id="error"></div>
    </div>
  </div>

  <div class="layout">
    <!-- Левая колонка -->
    <div class="card" style="display:flex;flex-direction:column;">
      <div class="row" style="justify-content:space-between;flex-wrap:wrap;">
        <div>
          <h1>Маникюр эффекты</h1>
          <div class="small">Выбери эффект, цвета, включай/выключай линии и эффекты.</div>
        </div>
        <div class="badge">Жест: <span id="gesture_name">—</span></div>
        <div class="badge">Уверенность: <span id="confidence">—</span></div>
      </div>

      <div class="video-wrapper">
        <video id="input_video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="panel" style="gap:10px;">
        <div class="form-group">
          <label for="effect_select">Эффект</label>
          <select id="effect_select">
            <option value="glow">Glow</option>
            <option value="sparkle">Sparkle</option>
            <option value="orbit">Orbit</option>
            <option value="burst">Burst</option>
            <option value="fire">Огонь</option>
            <option value="lightning">Молния</option>
            <option value="rainbow">Радуга</option>
            <option value="confetti">Конфетти</option>
            <option value="pulse">Пульс</option>
            <option value="stars">Звёздный вихрь</option>
            <option value="random">Случайный</option>
          </select>
        </div>
        <div class="form-group">
          <label for="primary_color">Основной цвет</label>
          <input type="color" id="primary_color" value="#7ae0ff">
        </div>
        <div class="form-group">
          <label for="accent_color">Акцентный</label>
          <input type="color" id="accent_color" value="#ff7ae0">
        </div>
        <div class="form-group">
          <label for="intensity">Интенсивность</label>
          <input type="range" id="intensity" min="0.2" max="2" step="0.1" value="1">
        </div>
        <div class="form-group" style="flex:0 0 auto;">
          <label>&nbsp;</label>
          <div class="controls">
            <button class="btn" id="new_design">Новый дизайн</button>
            <button class="btn" id="switch_cam">Фронт/задняя</button>
            <button class="btn outline" id="restart_cam">Перезапустить камеру</button>
          </div>
        </div>
      </div>

      <div class="toggles">
        <label class="checkbox-wrapper">
          <input type="checkbox" id="toggle_lines" checked><span>Показывать линии</span>
        </label>
        <label class="checkbox-wrapper">
          <input type="checkbox" id="toggle_effects" checked><span>Показывать эффекты</span>
        </label>
      </div>

      <div class="divider"></div>
      <div class="controls">
        <button class="btn" id="snapshot_btn">Снимок</button>
        <button class="btn" id="record_btn">Запись</button>
        <button class="btn outline" id="stop_btn" disabled>Стоп</button>
      </div>
      <div class="downloads" id="downloads"></div>
      <div class="small" style="margin-top:8px;">Эффект применяется сразу ко всем кончикам пальцев.</div>
    </div>

    <!-- Правая колонка -->
    <div class="card">
      <div class="row"><div class="badge">Текущий эффект</div></div>
      <div class="effect-box">
        <div class="small"><strong>Выбран:</strong> <span id="current_effect_label">Glow</span></div>
        <div class="small"><strong>Цвет основной:</strong> <span id="current_primary_label">#7ae0ff</span></div>
        <div class="small"><strong>Цвет акцентный:</strong> <span id="current_accent_label">#ff7ae0</span></div>
        <div class="small"><strong>Интенсивность:</strong> <span id="current_intensity_label">1.0</span></div>
      </div>
      <div class="divider"></div>
      <div class="small"><strong>Эффекты:</strong></div>
      <ul class="small">
        <li><strong>Glow:</strong> мягкое свечение.</li>
        <li><strong>Sparkle:</strong> блёстки.</li>
        <li><strong>Orbit:</strong> шарики по орбите.</li>
        <li><strong>Burst:</strong> лучи из точки.</li>
        <li><strong>Fire:</strong> пламя.</li>
        <li><strong>Lightning:</strong> молнии.</li>
        <li><strong>Rainbow:</strong> радужное кольцо.</li>
        <li><strong>Confetti:</strong> конфетти.</li>
        <li><strong>Pulse:</strong> пульсации.</li>
        <li><strong>Stars:</strong> звёзды по орбите.</li>
      </ul>
    </div>
  </div>

  <!-- зависимости -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    /*** ===== UI: LOADER ===== ***/
    const loader = document.getElementById('loader');
    const loaderBar = document.getElementById('loader_bar');
    const loaderPct = document.getElementById('loader_pct');
    const loaderStage = document.getElementById('loader_stage');
    const loaderSub = document.getElementById('loader_sub');
    const loaderErr = document.getElementById('error');

    function setProgress(pct, stage, sub){
      const v = Math.max(0, Math.min(100, Math.round(pct)));
      loaderBar.style.width = v + '%';
      loaderPct.textContent = v + '%';
      if (stage) loaderStage.textContent = stage;
      if (sub !== undefined) loaderSub.textContent = sub || '—';
      if (v >= 100) setTimeout(()=> loader.style.display = 'none', 150);
    }
    function showError(msg){
      loaderErr.style.display = 'block';
      loaderErr.textContent = String(msg || 'Неизвестная ошибка загрузки.');
    }

    /*** ===== DOM ===== ***/
    const video = document.getElementById('input_video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const gestureNameEl = document.getElementById('gesture_name');
    const confidenceEl = document.getElementById('confidence');
    const effectSelect = document.getElementById('effect_select');
    const primaryColorInput = document.getElementById('primary_color');
    const accentColorInput = document.getElementById('accent_color');
    const intensityInput = document.getElementById('intensity');
    const newDesignBtn = document.getElementById('new_design');
    const switchCamBtn = document.getElementById('switch_cam');
    const restartCamBtn = document.getElementById('restart_cam');
    const snapshotBtn = document.getElementById('snapshot_btn');
    const recordBtn = document.getElementById('record_btn');
    const stopBtn = document.getElementById('stop_btn');
    const downloads = document.getElementById('downloads');
    const currentEffectLabel = document.getElementById('current_effect_label');
    const currentPrimaryLabel = document.getElementById('current_primary_label');
    const currentAccentLabel = document.getElementById('current_accent_label');
    const currentIntensityLabel = document.getElementById('current_intensity_label');
    const toggleLinesCheckbox = document.getElementById('toggle_lines');
    const toggleEffectsCheckbox = document.getElementById('toggle_effects');

    let showLines = true, showEffects = true;
    let facingMode = 'user';
    let currentStream = null;
    let recorder = null, chunks = [];
    let lastTime = performance.now(), deltaTimeGlobal = 0;

    /*** ===== CONFIG / FX ===== ***/
    let config = {
      effect:'glow', primaryColor:'#7ae0ff', accentColor:'#ff7ae0', intensity:1.0,
      sparkles:[], confettis:[], stars:[],
      lightningActive:false, lightningTimer:0, pulsePhase:0, rainbowOffset:0
    };
    const FINGER_TIPS = [4,8,12,16,20];
    const MAX_CONFETTI=80, MAX_SPARKLES=40, MAX_STARS=30;

    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const hexToRgb = hex => { const c=hex.replace('#',''); const n=parseInt(c,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; };
    const rr=(a,b)=>a+Math.random()*(b-a);

    function updateLabels(){
      currentEffectLabel.textContent = effectSelect.selectedOptions[0].textContent;
      currentPrimaryLabel.textContent = config.primaryColor;
      currentAccentLabel.textContent = config.accentColor;
      currentIntensityLabel.textContent = config.intensity.toFixed(1);
    }
    function initSparkles(){ config.sparkles = Array.from({length:MAX_SPARKLES},()=>({xOff:rr(-10,10),yOff:rr(-10,10),vx:rr(-0.1,0.1),vy:rr(-0.1,0.1),life:Math.random(),maxLife:rr(0.7,1.5),size:rr(3,7)})); }
    function initConfetti(){ config.confettis = Array.from({length:MAX_CONFETTI},()=>({x:rr(-15,15),y:rr(-15,15),vx:rr(-0.2,0.2),vy:rr(0.5,1.5),rotation:Math.random()*Math.PI*2,size:rr(4,8),color:`hsl(${Math.random()*360},70%,70%)`,life:rr(0,1),maxLife:rr(1.5,3)})); }
    function initStars(){ config.stars = Array.from({length:MAX_STARS},()=>({angle:Math.random()*Math.PI*2,radius:rr(10,25),speed:rr(0.5,1.5),size:rr(3,6),phase:Math.random()*Math.PI*2})); }
    function triggerLightning(){ config.lightningActive=true; config.lightningTimer=0.15; }

    function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }
    function isExt(lm,mcp,pip,dip,tip){ const m=lm[mcp], p=lm[pip], t=lm[tip]; return dist(t,p) > dist(p,m); }
    function classifyGesture(lm){
      const i=isExt(lm,5,6,7,8), m=isExt(lm,9,10,11,12), r=isExt(lm,13,14,15,16), p=isExt(lm,17,18,19,20);
      const tt=lm[4], ti=lm[3], w=lm[0]; const th=dist(tt,w) > dist(ti,w)*1.2;
      if(!i&&!m&&!r&&!p&&!th) return {name:'Кулак',score:1};
      if(i&&m&&r&&p&&th) return {name:'Открытая',score:1};
      if(th&&!i&&!m&&!r&&!p) return {name:'Палец вверх',score:1};
      if(i&&m&&!r&&!p) return {name:'V',score:1};
      if(i&&!m&&!r&&!p) return {name:'Указание',score:1};
      return {name:'—',score:0};
    }

    function drawAtTip(x,y){
      const t = performance.now()/1000, intensity=config.intensity;

      if(config.effect==='glow'&&showEffects){
        const base=20*intensity, radius=base+Math.sin(t*3)*6, pc=hexToRgb(config.primaryColor);
        const g=ctx.createRadialGradient(x,y,radius*0.1,x,y,radius);
        g.addColorStop(0,`rgba(${pc.r},${pc.g},${pc.b},0.7)`); g.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill();
      }

      if(config.effect==='orbit'&&showEffects){
        const baseR=16*intensity;
        for(let i=0;i<5;i++){
          const ph=(i/5)*Math.PI*2+config.rainbowOffset, r=baseR+Math.sin(t*2+ph)*5;
          const cx=x+Math.cos(t+ph)*r*0.3, cy=y+Math.sin(t+ph)*r*0.3;
          ctx.fillStyle=config.accentColor; ctx.beginPath(); ctx.arc(cx,cy,5*intensity,0,Math.PI*2); ctx.fill();
        }
      }

      if(config.effect==='burst'&&showEffects){
        const spikes=10, maxR=28*intensity, pulse=Math.abs(Math.sin(t*3));
        for(let i=0;i<spikes;i++){
          const th=(i/spikes)*Math.PI*2, len=maxR*(0.6+0.4*pulse);
          ctx.strokeStyle=config.primaryColor; ctx.lineWidth=2*(0.5+0.5*pulse);
          ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.cos(th)*len,y+Math.sin(th)*len); ctx.stroke();
        }
      }

      if(config.effect==='sparkle'&&showEffects){
        for(const p of config.sparkles){
          p.xOff+=p.vx*deltaTimeGlobal*50; p.yOff+=p.vy*deltaTimeGlobal*50; p.life+=deltaTimeGlobal;
          if(p.life>=p.maxLife){ p.xOff=rr(-10,10); p.yOff=rr(-10,10); p.vx=rr(-0.1,0.1); p.vy=rr(-0.1,0.1); p.life=0; p.maxLife=rr(0.7,1.5); p.size=rr(3,7); }
          const alpha=1-(p.life/p.maxLife), px=x+p.xOff, py=y+p.yOff, size=p.size*alpha*intensity;
          ctx.save(); ctx.translate(px,py); ctx.rotate(t+p.life); ctx.fillStyle=`rgba(255,255,255,${alpha})`;
          ctx.beginPath(); const spikes=4, outer=size, inner=size*0.5;
          for(let i=0;i<spikes;i++){ const th=(Math.PI*2/5)*i-Math.PI/2; ctx.lineTo(Math.cos(th)*outer,Math.sin(th)*outer); const th2=th+Math.PI/5; ctx.lineTo(Math.cos(th2)*inner,Math.sin(th2)*inner); }
          ctx.closePath(); ctx.fill(); ctx.restore();
        }
      }

      if(config.effect==='fire'&&showEffects){
        for(const p of config.confettis){
          p.y += -Math.abs(p.vy)*deltaTimeGlobal*30*intensity; p.x += p.vx*deltaTimeGlobal*30*intensity; p.life+=deltaTimeGlobal;
          if(p.life>=p.maxLife){ p.x=rr(-10,10); p.y=rr(0,20); p.life=0; p.maxLife=rr(0.6,1.2); p.size=rr(6,12); }
          const prog=p.life/p.maxLife, alpha=1-prog, size=p.size*(1-prog*0.5)*intensity, fx=x+p.x, fy=y+p.y;
          const g=ctx.createRadialGradient(fx,fy,size*0.2,fx,fy,size);
          g.addColorStop(0,`rgba(255,255,180,${alpha})`); g.addColorStop(0.4,`rgba(255,160,60,${alpha*0.8})`); g.addColorStop(1,`rgba(100,40,10,0)`);
          ctx.fillStyle=g; ctx.beginPath(); ctx.arc(fx,fy,size,0,Math.PI*2); ctx.fill();
        }
      }

      if(config.effect==='lightning'&&showEffects){
        if(!config.lightningActive && Math.random()<0.009*config.intensity) triggerLightning();
        if(config.lightningActive){
          const lifeFrac=config.lightningTimer/0.15, alpha=lifeFrac;
          ctx.save(); ctx.lineWidth=2+2*(1-lifeFrac); ctx.strokeStyle=`rgba(180,220,255,${alpha})`; ctx.shadowColor=`rgba(180,220,255,${alpha})`; ctx.shadowBlur=8*lifeFrac;
          const len=30*intensity, seg=5; ctx.beginPath(); ctx.moveTo(x,y);
          for(let i=1;i<=seg;i++){ const tseg=i/seg, nx=x+Math.cos(tseg*Math.PI*2+config.rainbowOffset)*(len*(1-tseg*0.3))+rr(-5,5), ny=y+Math.sin(tseg*Math.PI*2+config.rainbowOffset)*(len*(1-tseg*0.3))+rr(-5,5); ctx.lineTo(nx,ny); }
          ctx.stroke(); ctx.restore();
        }
      }

      if(config.effect==='rainbow'&&showEffects){
        const radius=20*intensity, segments=60;
        for(let i=0;i<segments;i++){
          const a=(i/segments)*Math.PI*2+config.rainbowOffset, a2=((i+1)/segments)*Math.PI*2+config.rainbowOffset, h1=(i*6+t*60)%360, h2=((i+1)*6+t*60)%360;
          const grad=ctx.createLinearGradient(x+Math.cos(a)*radius,y+Math.sin(a)*radius,x+Math.cos(a2)*radius,y+Math.sin(a2)*radius);
          grad.addColorStop(0,`hsl(${h1},80%,65%)`); grad.addColorStop(1,`hsl(${h2},80%,65%)`);
          ctx.strokeStyle=grad; ctx.lineWidth=6*intensity; ctx.beginPath(); ctx.arc(x,y,radius,a,a2); ctx.stroke();
        }
      }

      if(config.effect==='confetti'&&showEffects){
        for(const p of config.confettis){
          p.y+=p.vy*deltaTimeGlobal*30*intensity; p.x+=p.vx*deltaTimeGlobal*30*intensity; p.rotation+=0.05*deltaTimeGlobal*60; p.life+=deltaTimeGlobal;
          if(p.life>=p.maxLife){ p.x=rr(-15,15); p.y=rr(-15,15); p.vx=rr(-0.2,0.2); p.vy=rr(0.5,1.5); p.rotation=Math.random()*Math.PI*2; p.life=0; p.maxLife=rr(1.5,3); p.size=rr(4,8); }
          const alpha=1-(p.life/p.maxLife); ctx.save(); ctx.translate(x+p.x,y+p.y); ctx.rotate(p.rotation); ctx.fillStyle=p.color; ctx.globalAlpha=alpha; ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size); ctx.restore();
        }
      }

      if(config.effect==='pulse'&&showEffects){
        const base=15*intensity, pulse=Math.abs(Math.sin(t*2+config.pulsePhase)), radius=base+pulse*12;
        ctx.strokeStyle=config.accentColor; ctx.lineWidth=3*pulse; ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.stroke();
      }

      if(config.effect==='stars'&&showEffects){
        for(const s of config.stars){
          s.angle+=s.speed*deltaTimeGlobal*0.5;
          const r=s.radius*(0.8+0.2*Math.sin(t+s.phase)), sx=x+Math.cos(s.angle+config.pulsePhase)*r, sy=y+Math.sin(s.angle+config.pulsePhase)*r, size=s.size*(1+0.3*Math.sin(t+s.phase));
          ctx.save(); ctx.translate(sx,sy); ctx.rotate(t+s.phase); ctx.fillStyle=config.accentColor; ctx.beginPath();
          for(let i=0;i<5;i++){ const th=(Math.PI*2/5)*i-Math.PI/2, outer=size, inner=size*0.5; if(i===0) ctx.moveTo(Math.cos(th)*outer,Math.sin(th)*outer); else ctx.lineTo(Math.cos(th)*outer,Math.sin(th)*outer); const th2=th+Math.PI/5; ctx.lineTo(Math.cos(th2)*inner,Math.sin(th2)*inner); }
          ctx.closePath(); ctx.fill(); ctx.restore();
        }
      }

      if(config.lightningActive){ config.lightningTimer-=deltaTimeGlobal; if(config.lightningTimer<=0){ config.lightningActive=false; config.lightningTimer=0; } }
      config.rainbowOffset+=deltaTimeGlobal*0.8; config.pulsePhase+=deltaTimeGlobal*1.2;
    }

    /*** ===== MediaPipe Hands with PRELOAD & PROGRESS ===== ***/
    const MP_BASE = 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/';
    // Имена ассетов — проверь по Network при необходимости
    const ASSETS = [
      'hands_solution_packed_assets.data',
      'hands_solution_packed_assets_loader.js',
      'hands_solution_simd_wasm_bin.wasm',
      'hands_solution_simd_wasm.js'
    ];

    async function prefetchAssetsEqualSlices(){
      setProgress(8,'Подготовка','Проверка ассетов');
      const blobs = {};
      let doneFiles = 0;
      const totalSlice = 70;  // 8%..78% за файлы (по ~равным долям)
      const perFile = totalSlice / ASSETS.length;

      for(const name of ASSETS){
        try{
          setProgress(10 + doneFiles*perFile, 'Загрузка модели', 'Получение '+name);
          const res = await fetch(MP_BASE + name, { cache:'force-cache' });
          if(!res.ok) throw new Error(name+' HTTP '+res.status);
          const reader = res.body && res.body.getReader ? res.body.getReader() : null;
          const chunks = [];
          if(reader){
            for(;;){
              const {done, value} = await reader.read();
              if(done) break;
              chunks.push(value);
            }
          }else{
            chunks.push(new Uint8Array(await res.arrayBuffer()));
          }
          blobs[name] = URL.createObjectURL(new Blob(chunks));
          doneFiles++;
          setProgress(10 + doneFiles*perFile, 'Загрузка модели', `${doneFiles}/${ASSETS.length} файлов`);
        }catch(e){
          showError('Не удалось загрузить '+name+': '+e.message);
          // Фолбэк — позволим hands.js подтянуть оставшееся с CDN
        }
      }

      setProgress(82,'Инициализация MediaPipe','Создание Hands');
      const locateFile = (file) => blobs[file] || (MP_BASE + file);
      return locateFile;
    }

    let hands = null;
    let firstResult = false;

    function onResults(results){
      ctx.save();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(results.image,0,0,canvas.width,canvas.height);

      if(results.multiHandLandmarks && results.multiHandLandmarks.length){
        const lm = results.multiHandLandmarks[0];
        if(showLines){
          drawConnectors(ctx, lm, HAND_CONNECTIONS, {color:'#7ae0ff', lineWidth:3});
          drawLandmarks(ctx, lm, {color:'#ffffff', radius:4});
        }
        const g = classifyGesture(lm);
        gestureNameEl.textContent = g.name;
        confidenceEl.textContent = `${Math.round(g.score*100)}%`;

        for(const i of FINGER_TIPS){
          const tip = lm[i]; if(!tip) continue;
          const x = tip.x * canvas.width, y = tip.y * canvas.height;
          if(showEffects) drawAtTip(x,y);
        }
      }else{
        gestureNameEl.textContent = '—';
        confidenceEl.textContent = '';
      }
      ctx.restore();

      if(!firstResult){
        firstResult = true;
        setProgress(100, 'Готово','Модель и камера активны');
      }
    }

    async function buildHands(){
      const locateFile = await prefetchAssetsEqualSlices();
      hands = new Hands({ locateFile });
      hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.6 });
      hands.onResults(onResults);
    }

    /*** ===== Camera ===== ***/
    async function startCamera(){
      if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream=null; }
      try{
        setProgress(85,'Камера','Запрос доступа');
        const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode }, audio:false });
        currentStream = stream;
        video.srcObject = stream;
        await video.play();
        if (video.readyState >= 2) resizeCanvas();
        else video.onloadedmetadata = resizeCanvas;
        setProgress(90,'Камера','Поток запущен');
        requestAnimationFrame(loop);
      }catch(e){
        showError('Камера недоступна: '+e.message);
      }
    }

    function resizeCanvas(){
      if(video.videoWidth && video.videoHeight){
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
      }
    }

    async function loop(){
      const now = performance.now();
      deltaTimeGlobal = (now - lastTime)/1000;
      lastTime = now;
      if(video.readyState >= 2 && hands){
        await hands.send({ image: video });
      }
      requestAnimationFrame(loop);
    }

    /*** ===== UI EVENTS ===== ***/
    effectSelect.addEventListener('change', ()=>{ config.effect = effectSelect.value==='random'? randomEffect():effectSelect.value; updateLabels(); });
    primaryColorInput.addEventListener('input', ()=>{ config.primaryColor = primaryColorInput.value; updateLabels(); });
    accentColorInput.addEventListener('input', ()=>{ config.accentColor = accentColorInput.value; updateLabels(); });
    intensityInput.addEventListener('input', ()=>{ config.intensity = parseFloat(intensityInput.value); updateLabels(); });
    newDesignBtn.addEventListener('click', ()=>{ config.effect = effectSelect.value==='random'? randomEffect():effectSelect.value; config.primaryColor = primaryColorInput.value; config.accentColor = accentColorInput.value; config.intensity = parseFloat(intensityInput.value); initSparkles(); initConfetti(); initStars(); updateLabels(); });
    switchCamBtn.addEventListener('click', ()=>{ facingMode = (facingMode==='user') ? 'environment' : 'user'; startCamera(); });
    restartCamBtn.addEventListener('click', ()=> startCamera());
    toggleLinesCheckbox.addEventListener('change', e=> showLines = e.target.checked);
    toggleEffectsCheckbox.addEventListener('change', e=> showEffects = e.target.checked);

    snapshotBtn.addEventListener('click', ()=>{
      const a = document.createElement('a');
      a.download = `manicure_effect_${Date.now()}.png`;
      a.href = canvas.toDataURL('image/png');
      a.click();
      const div = document.createElement('div');
      div.innerHTML = `📸 <a href="${a.href}" download="${a.download}">Скачать снимок</a>`;
      downloads.prepend(div);
    });

    recordBtn.addEventListener('click', ()=>{
      if(recorder) return;
      const stream = canvas.captureStream(30);
      try{ recorder = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'}); }catch{ recorder = new MediaRecorder(stream); }
      chunks = [];
      recorder.ondataavailable = e=>{ if(e.data.size) chunks.push(e.data); };
      recorder.onstop = ()=>{
        const blob = new Blob(chunks, {type:'video/webm'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `manicure_effect_video_${Date.now()}.webm`; a.textContent = '🎬 Скачать видео';
        const div = document.createElement('div'); div.appendChild(a); downloads.prepend(div);
        recorder=null; stopBtn.disabled=true; recordBtn.disabled=false;
      };
      recorder.start(); recordBtn.disabled=true; stopBtn.disabled=false;
    });
    stopBtn.addEventListener('click', ()=>{ if(recorder) recorder.stop(); });

    function randomEffect(){ const o=['glow','sparkle','orbit','burst','fire','lightning','rainbow','confetti','pulse','stars']; return o[Math.floor(Math.random()*o.length)]; }

    /*** ===== INIT ===== ***/
    (async function init(){
      try{
        setProgress(3,'Инициализация','Старт');
        config.effect='glow'; initSparkles(); initConfetti(); initStars(); updateLabels();
        await buildHands();                // 8%..82%
        await startCamera();               // 85%..90%
        setProgress(95,'Ожидание первого кадра','MediaPipe обрабатывает…');
      }catch(e){
        showError(e.message || e);
      }
    })();
  </script>
</body>
</html>
