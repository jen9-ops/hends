<!DOCTYPE html><html><head><style></style></head><body><!DOCTYPE html>

<html lang="ru">

<head>

<meta charset="utf-8"/>

<title>Маникюр: unified эффекты с переключением линий и эффектов</title>

<meta name="viewport" content="width=device-width,initial-scale=1"/>

<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">

<style>

  :root {

    --bg:#0f1220;

    --card:rgba(30,40,80,.95);

    --radius:14px;

    --accent:#7ae0ff;

    --muted:#8f9acb;

    --shadow:0 40px 100px -10px rgba(0,0,0,.6);

  }

  *{box-sizing:border-box;}

  body {

    margin:0;

    font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;

    background: var(--bg);

    color:#eef2fc;

  }

  .layout {

    max-width: 1200px;

    margin: auto;

    padding: 14px;

    display: grid;

    grid-template-columns: 2fr 1fr;

    gap: 18px;

  }

  @media (max-width: 1000px) {

    .layout { grid-template-columns: 1fr; }

  }

  .card {

    background: var(--card);

    border-radius: var(--radius);

    padding: 18px;

    position: relative;

    box-shadow: var(--shadow);

  }

  h1 {

    margin:0;

    font-size: 1.6rem;

    font-weight:600;

  }

  .video-wrapper {

    position: relative;

    border-radius:12px;

    overflow:hidden;

    background:#0b0f1e;

    aspect-ratio:4/3;

    margin-top:8px;

    margin-bottom:12px;

  }

  video, canvas {

    position:absolute;

    inset:0;

    width:100%;

    height:100%;

    object-fit:cover;

    border-radius:12px;

  }

  .row {

    display:flex;

    gap:12px;

    flex-wrap:wrap;

    align-items:center;

    margin-bottom:10px;

  }

  .form-group {

    display:flex;

    flex-direction: column;

    gap:4px;

    flex:1;

    min-width:140px;

  }

  label {

    font-size:12px;

    margin-bottom:2px;

    text-transform: uppercase;

    letter-spacing:0.5px;

  }

  select, input[type=color], input[type=range] {

    padding:8px 10px;

    border-radius:8px;

    border:none;

    background:rgba(255,255,255,.06);

    color:#eef2fc;

    font-size:14px;

    outline:none;

    appearance:none;

  }

  input[type=range] { width:100%; }

  .btn {

    padding:10px 16px;

    border:none;

    border-radius:10px;

    cursor:pointer;

    font-weight:600;

    display:inline-flex;

    align-items:center;

    gap:6px;

    background: linear-gradient(135deg,#4da3ff,#7ae0ff);

    color:#0f1220;

  }

  .btn.outline {

    background:transparent;

    border:2px solid var(--accent);

    color: var(--accent);

  }

  .badge {

    background: rgba(122,224,255,.15);

    padding:6px 14px;

    border-radius:999px;

    font-size:13px;

    display:inline-block;

    font-weight:600;

  }

  .controls {

    display:flex;

    gap:12px;

    flex-wrap:wrap;

    margin-top:6px;

  }

  .downloads {

    margin-top:10px;

    display:flex;

    flex-direction:column;

    gap:6px;

    font-size:14px;

  }

  .effect-box {

    background: rgba(255,255,255,.04);

    border-radius:10px;

    padding:12px;

    margin-top:8px;

  }

  .small {

    font-size:13px;

    color: var(--muted);

  }

  .divider {

    height:1px;

    background: rgba(255,255,255,.08);

    margin:12px 0;

  }

  .toggles {

    display:flex;

    gap:14px;

    flex-wrap:wrap;

    align-items:center;

  }

  .checkbox-wrapper {

    display:inline-flex;

    align-items:center;

    gap:6px;

    font-size:13px;

    background: rgba(255,255,255,.05);

    padding:6px 10px;

    border-radius:8px;

  }

  .checkbox-wrapper input {

    margin:0;

    accent-color: #7ae0ff;

    width:16px;

    height:16px;

  }

</style>

</head>

<body>

<div class="layout">

  <!-- Левая: видео + формы + управление -->

  <div class="card" style="display:flex;flex-direction:column;">

    <div class="row" style="justify-content: space-between; flex-wrap:wrap;">

      <div>

        <h1>Маникюр эффекты</h1>

        <div class="small">Выбери эффект, цвета, включай/выключай линии и эффекты.</div>

      </div>

      <div class="badge">Жест: <span id="gesture_name">—</span></div>

      <div class="badge">Уверенность: <span id="confidence">—</span></div>

    </div>

    <div class="video-wrapper">

      <video id="input_video" playsinline muted></video>

      <canvas id="overlay"></canvas>

    </div>

    <div class="panel" style="gap:10px;">

      <div class="form-group">

        <label for="effect_select">Эффект</label>

        <select id="effect_select">

          <option value="glow">Glow</option>

          <option value="sparkle">Sparkle</option>

          <option value="orbit">Orbit</option>

          <option value="burst">Burst</option>

          <option value="fire">Огонь</option>

          <option value="lightning">Молния</option>

          <option value="rainbow">Радуга</option>

          <option value="confetti">Конфетти</option>

          <option value="pulse">Пульс</option>

          <option value="stars">Звёздный вихрь</option>

          <option value="random">Случайный</option>

        </select>

      </div>

      <div class="form-group">

        <label for="primary_color">Основной цвет</label>

        <input type="color" id="primary_color" value="#7ae0ff">

      </div>

      <div class="form-group">

        <label for="accent_color">Акцентный</label>

        <input type="color" id="accent_color" value="#ff7ae0">

      </div>

      <div class="form-group">

        <label for="intensity">Интенсивность</label>

        <input type="range" id="intensity" min="0.2" max="2" step="0.1" value="1">

      </div>

      <div class="form-group" style="flex:0 0 auto;">

        <label>&nbsp;</label>

        <div class="controls">

          <button class="btn" id="new_design">Новый дизайн</button>

          <button class="btn" id="switch_cam">Фронт/задняя</button>

        </div>

      </div>

    </div>

    <div class="toggles">

      <div class="checkbox-wrapper">

        <input type="checkbox" id="toggle_lines" checked>

        <label for="toggle_lines">Показывать линии</label>

      </div>

      <div class="checkbox-wrapper">

        <input type="checkbox" id="toggle_effects" checked>

        <label for="toggle_effects">Показывать эффекты</label>

      </div>

    </div>

    <div class="divider"></div>

    <div class="controls">

      <button class="btn" id="snapshot_btn">Снимок</button>

      <button class="btn" id="record_btn">Запись</button>

      <button class="btn outline" id="stop_btn" disabled>Стоп</button>

    </div>

    <div class="downloads" id="downloads"></div>

    <div class="small" style="margin-top:8px;">

      Эффект применяется сразу ко всем кончикам пальцев. Отключай линии или эффекты через чекбоксы.

    </div>

  </div>

  <!-- Правая: пояснения / текущий дизайн -->

  <div class="card">

    <div class="row">

      <div class="badge">Текущий эффект</div>

    </div>

    <div class="effect-box">

      <div class="small"><strong>Выбран:</strong> <span id="current_effect_label">Glow</span></div>

      <div class="small"><strong>Цвет основной:</strong> <span id="current_primary_label">#7ae0ff</span></div>

      <div class="small"><strong>Цвет акцентный:</strong> <span id="current_accent_label">#ff7ae0</span></div>

      <div class="small"><strong>Интенсивность:</strong> <span id="current_intensity_label">1.0</span></div>

    </div>

    <div class="divider"></div>

    <div class="small"><strong>Эффекты:</strong></div>

    <ul class="small">

      <li><strong>Glow:</strong> мягкое свечение вокруг кончиков.</li>

      <li><strong>Sparkle:</strong> мелкие блестки.</li>

      <li><strong>Orbit:</strong> вращающиеся шарики.</li>

      <li><strong>Burst:</strong> лучи, расходящиеся из точки.</li>

      <li><strong>Fire:</strong> пламя.</li>

      <li><strong>Lightning:</strong> краткие молнии.</li>

      <li><strong>Rainbow:</strong> вращающийся радужный ореол.</li>

      <li><strong>Confetti:</strong> падающие кусочки конфетти.</li>

      <li><strong>Pulse:</strong> пульсирующие круги.</li>

      <li><strong>Stars:</strong> вращающийся звездный вихрь.</li>

    </ul>

  </div>

</div>

<!-- зависимости -->

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>

// DOM

const video = document.getElementById('input_video');

const canvas = document.getElementById('overlay');

const ctx = canvas.getContext('2d');

const gestureNameEl = document.getElementById('gesture_name');

const confidenceEl = document.getElementById('confidence');

const effectSelect = document.getElementById('effect_select');

const primaryColorInput = document.getElementById('primary_color');

const accentColorInput = document.getElementById('accent_color');

const intensityInput = document.getElementById('intensity');

const newDesignBtn = document.getElementById('new_design');

const switchCamBtn = document.getElementById('switch_cam');

const snapshotBtn = document.getElementById('snapshot_btn');

const recordBtn = document.getElementById('record_btn');

const stopBtn = document.getElementById('stop_btn');

const downloads = document.getElementById('downloads');

const currentEffectLabel = document.getElementById('current_effect_label');

const currentPrimaryLabel = document.getElementById('current_primary_label');

const currentAccentLabel = document.getElementById('current_accent_label');

const currentIntensityLabel = document.getElementById('current_intensity_label');

const toggleLinesCheckbox = document.getElementById('toggle_lines');

const toggleEffectsCheckbox = document.getElementById('toggle_effects');

let showLines = true;

let showEffects = true;

let facingMode = 'user';

let currentStream = null;

let recorder = null;

let chunks = [];

let lastTime = performance.now();

let deltaTimeGlobal = 0;

let config = {

  effect: 'glow',

  primaryColor: '#7ae0ff',

  accentColor: '#ff7ae0',

  intensity: 1.0,

  sparkles: [],

  confettis: [],

  stars: [],

  lightningActive: false,

  lightningTimer: 0,

  pulsePhase: 0,

  rainbowOffset: 0

};

const FINGER_TIPS = [4, 8, 12, 16, 20];

const MAX_CONFETTI = 80;

const MAX_SPARKLES = 40;

const MAX_STARS = 30;

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

function lerp(a,b,t){ return a + (b-a)*t;}

function hexToRgb(hex) {

  const c = hex.replace('#','');

  const bigint = parseInt(c,16);

  return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };

}

function randomRange(min,max){ return min + Math.random()*(max-min); }

function updateLabels(){

  currentEffectLabel.textContent = effectSelect.selectedOptions[0].textContent;

  currentPrimaryLabel.textContent = config.primaryColor;

  currentAccentLabel.textContent = config.accentColor;

  currentIntensityLabel.textContent = config.intensity.toFixed(1);

}

function initSparkles(){

  config.sparkles = [];

  for(let i=0;i<MAX_SPARKLES;i++){

    config.sparkles.push({

      xOff: randomRange(-10,10),

      yOff: randomRange(-10,10),

      vx: randomRange(-0.1,0.1),

      vy: randomRange(-0.1,0.1),

      life: Math.random(),

      maxLife: randomRange(0.7,1.5),

      size: randomRange(3,7)

    });

  }

}

function initConfetti(){

  config.confettis = [];

  for(let i=0;i<MAX_CONFETTI;i++){

    config.confettis.push({

      x: randomRange(-15,15),

      y: randomRange(-15,15),

      vx: randomRange(-0.2,0.2),

      vy: randomRange(0.5,1.5),

      rotation: Math.random()*Math.PI*2,

      size: randomRange(4,8),

      color: `hsl(${Math.random()*360},70%,70%)`,

      life: randomRange(0,1),

      maxLife: randomRange(1.5,3)

    });

  }

}

function initStars(){

  config.stars = [];

  for(let i=0;i<MAX_STARS;i++){

    config.stars.push({

      angle: Math.random()*Math.PI*2,

      radius: randomRange(10,25),

      speed: randomRange(0.5,1.5),

      size: randomRange(3,6),

      phase: Math.random()*Math.PI*2

    });

  }

}

function triggerLightning(){

  config.lightningActive = true;

  config.lightningTimer = 0.15;

}

function distance(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

function isExtended(landmarks,mcp,pip,dip,tip){

  const m=landmarks[mcp], p=landmarks[pip], t=landmarks[tip];

  return distance(t,p) > distance(p,m);

}

function classifyGesture(landmarks){

  const indexExt = isExtended(landmarks,5,6,7,8);

  const middleExt = isExtended(landmarks,9,10,11,12);

  const ringExt = isExtended(landmarks,13,14,15,16);

  const pinkyExt = isExtended(landmarks,17,18,19,20);

  const thumbTip = landmarks[4], thumbIP=landmarks[3], wrist=landmarks[0];

  const thumbExt = distance(thumbTip,wrist) > distance(thumbIP,wrist)*1.2;

  if(!indexExt && !middleExt && !ringExt && !pinkyExt && !thumbExt) return {name:'Кулак', score:1};

  if(indexExt && middleExt && ringExt && pinkyExt && thumbExt) return {name:'Открытая', score:1};

  if(thumbExt && !indexExt && !middleExt && !ringExt && !pinkyExt) return {name:'Палец вверх', score:1};

  if(indexExt && middleExt && !ringExt && !pinkyExt) return {name:'V', score:1};

  if(indexExt && !middleExt && !ringExt && !pinkyExt) return {name:'Указание', score:1};

  return {name:'—', score:0};

}

function drawAtTip(x,y){

  const t = performance.now()/1000;

  const intensity = config.intensity;

  if(config.effect === 'glow' && showEffects){

    const base = 20 * intensity;

    const radius = base + Math.sin(t*3)*6;

    const pc = hexToRgb(config.primaryColor);

    const gradient = ctx.createRadialGradient(x,y, radius*0.1, x,y,radius);

    gradient.addColorStop(0, `rgba(${pc.r},${pc.g},${pc.b},0.7)`);

    gradient.addColorStop(1, 'rgba(0,0,0,0)');

    ctx.fillStyle = gradient;

    ctx.beginPath();

    ctx.arc(x,y,radius,0,Math.PI*2);

    ctx.fill();

  }

  if(config.effect === 'orbit' && showEffects){

    const baseR = 16 * intensity;

    for(let i=0;i<5;i++){

      const phase = (i / 5)*Math.PI*2 + config.rainbowOffset;

      const r = baseR + Math.sin(t*2 + phase)*5;

      const cx = x + Math.cos(t + phase)*r*0.3;

      const cy = y + Math.sin(t + phase)*r*0.3;

      ctx.fillStyle = config.accentColor;

      ctx.beginPath();

      ctx.arc(cx, cy, 5 * intensity, 0, Math.PI*2);

      ctx.fill();

    }

  }

  if(config.effect === 'burst' && showEffects){

    const spikes = 10;

    const maxR = 28 * intensity;

    const pulse = Math.abs(Math.sin(t*3));

    for(let i=0;i<spikes;i++){

      const theta = (i / spikes) * Math.PI*2;

      const len = maxR * (0.6 + 0.4 * pulse);

      const x2 = x + Math.cos(theta)*len;

      const y2 = y + Math.sin(theta)*len;

      ctx.strokeStyle = config.primaryColor;

      ctx.lineWidth = 2 * (0.5 + 0.5*pulse);

      ctx.beginPath();

      ctx.moveTo(x,y);

      ctx.lineTo(x2,y2);

      ctx.stroke();

    }

  }

  if(config.effect === 'sparkle' && showEffects){

    config.sparkles.forEach(p=>{

      p.xOff += p.vx * deltaTimeGlobal * 50;

      p.yOff += p.vy * deltaTimeGlobal * 50;

      p.life += deltaTimeGlobal;

      if(p.life >= p.maxLife){

        p.xOff = randomRange(-10,10);

        p.yOff = randomRange(-10,10);

        p.vx = randomRange(-0.1,0.1);

        p.vy = randomRange(-0.1,0.1);

        p.life = 0;

        p.maxLife = randomRange(0.7,1.5);

        p.size = randomRange(3,7);

      }

      const alpha = 1 - (p.life / p.maxLife);

      const px = x + p.xOff;

      const py = y + p.yOff;

      const size = p.size * alpha * intensity;

      ctx.save();

      ctx.translate(px, py);

      ctx.rotate(t + p.life);

      ctx.fillStyle = `rgba(255,255,255,${alpha})`;

      ctx.beginPath();

      const spikes = 4;

      const outer = size;

      const inner = size * 0.5;

      for(let i=0;i<spikes;i++){

        const theta = (Math.PI*2/5)*i - Math.PI/2;

        ctx.lineTo(Math.cos(theta)*outer, Math.sin(theta)*outer);

        const theta2 = theta + Math.PI/5;

        ctx.lineTo(Math.cos(theta2)*inner, Math.sin(theta2)*inner);

      }

      ctx.closePath();

      ctx.fill();

      ctx.restore();

    });

  }

  if(config.effect === 'fire' && showEffects){

    config.confettis.forEach(p=>{

      p.y += -Math.abs(p.vy) * deltaTimeGlobal * 30 * intensity;

      p.x += p.vx * deltaTimeGlobal * 30 * intensity;

      p.life += deltaTimeGlobal;

      if(p.life >= p.maxLife){

        p.x = randomRange(-10,10);

        p.y = randomRange(0,20);

        p.life = 0;

        p.maxLife = randomRange(0.6,1.2);

        p.size = randomRange(6,12);

      }

      const progress = p.life / p.maxLife;

      const alpha = 1 - progress;

      const size = p.size * (1 - progress*0.5) * intensity;

      const fx = x + p.x;

      const fy = y + p.y;

      const grad = ctx.createRadialGradient(fx,fy,size*0.2,fx,fy,size);

      grad.addColorStop(0, `rgba(255,255,180,${alpha})`);

      grad.addColorStop(0.4, `rgba(255,160,60,${alpha*0.8})`);

      grad.addColorStop(1, `rgba(100,40,10,0)`);

      ctx.fillStyle = grad;

      ctx.beginPath();

      ctx.arc(fx, fy, size, 0, Math.PI*2);

      ctx.fill();

    });

  }

  if(config.effect === 'lightning' && showEffects){

    if(!config.lightningActive){

      if(Math.random() < 0.009 * config.intensity){

        triggerLightning();

      }

    }

    if(config.lightningActive){

      const lifeFrac = config.lightningTimer / 0.15;

      const alpha = lifeFrac;

      ctx.save();

      ctx.lineWidth = 2 + 2*(1-lifeFrac);

      ctx.strokeStyle = `rgba(180,220,255,${alpha})`;

      ctx.shadowColor = `rgba(180,220,255,${alpha})`;

      ctx.shadowBlur = 8 * lifeFrac;

      const len = 30 * intensity;

      const segments = 5;

      ctx.beginPath();

      ctx.moveTo(x,y);

      for(let i=1;i<=segments;i++){

        const tseg = i / segments;

        const nx = x + Math.cos(tseg * Math.PI*2 + config.rainbowOffset) * (len * (1 - tseg*0.3)) + randomRange(-5,5);

        const ny = y + Math.sin(tseg * Math.PI*2 + config.rainbowOffset) * (len * (1 - tseg*0.3)) + randomRange(-5,5);

        ctx.lineTo(nx, ny);

      }

      ctx.stroke();

      ctx.restore();

    }

  }

  if(config.effect === 'rainbow' && showEffects){

    const radius = 20 * intensity;

    const segments = 60;

    for(let i=0;i<segments;i++){

      const angle = (i / segments) * Math.PI*2 + config.rainbowOffset;

      const nextAngle = ((i+1)/segments) * Math.PI*2 + config.rainbowOffset;

      const h1 = (i*6 + t*60)%360;

      const h2 = ((i+1)*6 + t*60)%360;

      const gradient = ctx.createLinearGradient(

        x + Math.cos(angle)*radius, y + Math.sin(angle)*radius,

        x + Math.cos(nextAngle)*radius, y + Math.sin(nextAngle)*radius

      );

      gradient.addColorStop(0, `hsl(${h1},80%,65%)`);

      gradient.addColorStop(1, `hsl(${h2},80%,65%)`);

      ctx.strokeStyle = gradient;

      ctx.lineWidth = 6 * intensity;

      ctx.beginPath();

      ctx.arc(x, y, radius, angle, nextAngle);

      ctx.stroke();

    }

  }

  if(config.effect === 'confetti' && showEffects){

    config.confettis.forEach(p=>{

      p.y += p.vy * deltaTimeGlobal * 30 * intensity;

      p.x += p.vx * deltaTimeGlobal * 30 * intensity;

      p.rotation += 0.05 * deltaTimeGlobal * 60;

      p.life += deltaTimeGlobal;

      if(p.life >= p.maxLife){

        p.x = randomRange(-15,15);

        p.y = randomRange(-15,15);

        p.vx = randomRange(-0.2,0.2);

        p.vy = randomRange(0.5,1.5);

        p.rotation = Math.random()*Math.PI*2;

        p.life = 0;

        p.maxLife = randomRange(1.5,3);

        p.size = randomRange(4,8);

      }

      const alpha = 1 - (p.life / p.maxLife);

      ctx.save();

      ctx.translate(x + p.x, y + p.y);

      ctx.rotate(p.rotation);

      ctx.fillStyle = p.color;

      ctx.globalAlpha = alpha;

      ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);

      ctx.restore();

    });

  }

  if(config.effect === 'pulse' && showEffects){

    const base = 15 * intensity;

    const pulse = Math.abs(Math.sin(t*2 + config.pulsePhase));

    const radius = base + pulse * 12;

    ctx.strokeStyle = config.accentColor;

    ctx.lineWidth = 3 * pulse;

    ctx.beginPath();

    ctx.arc(x,y,radius,0,Math.PI*2);

    ctx.stroke();

  }

  if(config.effect === 'stars' && showEffects){

    config.stars.forEach(s=>{

      s.angle += s.speed * deltaTimeGlobal * 0.5;

      const r = s.radius * (0.8 + 0.2 * Math.sin(t + s.phase));

      const sx = x + Math.cos(s.angle + config.pulsePhase) * r;

      const sy = y + Math.sin(s.angle + config.pulsePhase) * r;

      const size = s.size * (1 + 0.3 * Math.sin(t + s.phase));

      ctx.save();

      ctx.translate(sx, sy);

      ctx.rotate(t + s.phase);

      ctx.fillStyle = config.accentColor;

      ctx.beginPath();

      for(let i=0;i<5;i++){

        const theta = (Math.PI*2/5)*i - Math.PI/2;

        const outer = size;

        const inner = size * 0.5;

        if(i===0) ctx.moveTo(Math.cos(theta)*outer, Math.sin(theta)*outer);

        else ctx.lineTo(Math.cos(theta)*outer, Math.sin(theta)*outer);

        const theta2 = theta + Math.PI/5;

        ctx.lineTo(Math.cos(theta2)*inner, Math.sin(theta2)*inner);

      }

      ctx.closePath();

      ctx.fill();

      ctx.restore();

    });

  }

  if(config.lightningActive){

    config.lightningTimer -= deltaTimeGlobal;

    if(config.lightningTimer <= 0){

      config.lightningActive = false;

      config.lightningTimer = 0;

    }

  }

  config.rainbowOffset += deltaTimeGlobal * 0.8;

  config.pulsePhase += deltaTimeGlobal * 1.2;

}

const hands = new Hands({

  locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`

});

hands.setOptions({

  maxNumHands:1,

  modelComplexity:1,

  minDetectionConfidence:0.7,

  minTrackingConfidence:0.6

});

hands.onResults(onResults);

async function startCamera(){

  if(currentStream){

    currentStream.getTracks().forEach(t=>t.stop());

    currentStream = null;

  }

  try{

    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode: facingMode}, audio:false});

    currentStream = stream;

    video.srcObject = stream;

    await video.play();

    resizeCanvas();

    requestAnimationFrame(loop);

  } catch(e){

    console.warn("Камера не доступна", e);

  }

}

function resizeCanvas(){

  if(video.videoWidth && video.videoHeight){

    canvas.width = video.videoWidth;

    canvas.height = video.videoHeight;

  }

}

async function loop(){

  const now = performance.now();

  deltaTimeGlobal = (now - lastTime)/1000;

  lastTime = now;

  if(video.readyState >= 2){

    await hands.send({image: video});

  }

  requestAnimationFrame(loop);

}

function onResults(results){

  ctx.save();

  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.drawImage(results.image,0,0,canvas.width,canvas.height);

  if(results.multiHandLandmarks && results.multiHandLandmarks.length){

    const lm = results.multiHandLandmarks[0];

    if(showLines){

      drawConnectors(ctx, lm, HAND_CONNECTIONS, {color:'#7ae0ff', lineWidth:3});

      drawLandmarks(ctx, lm, {color:'#ffffff', radius:4});

    }

    const g = classifyGesture(lm);

    gestureNameEl.textContent = g.name;

    confidenceEl.textContent = `${Math.round(g.score*100)}%`;

    FINGER_TIPS.forEach(i=>{

      const tip = lm[i];

      if(!tip) return;

      const x = tip.x * canvas.width;

      const y = tip.y * canvas.height;

      if(showEffects) drawAtTip(x,y);

    });

  } else {

    gestureNameEl.textContent='—';

    confidenceEl.textContent='';

  }

  ctx.restore();

}

// UI events

effectSelect.addEventListener('change', ()=>{

  config.effect = effectSelect.value === 'random' ? randomEffect() : effectSelect.value;

  updateLabels();

});

primaryColorInput.addEventListener('input', ()=>{

  config.primaryColor = primaryColorInput.value;

  updateLabels();

});

accentColorInput.addEventListener('input', ()=>{

  config.accentColor = accentColorInput.value;

  updateLabels();

});

intensityInput.addEventListener('input', ()=>{

  config.intensity = parseFloat(intensityInput.value);

  updateLabels();

});

newDesignBtn.addEventListener('click', ()=>{

  if(effectSelect.value === 'random') config.effect = randomEffect();

  else config.effect = effectSelect.value;

  config.primaryColor = primaryColorInput.value;

  config.accentColor = accentColorInput.value;

  config.intensity = parseFloat(intensityInput.value);

  initSparkles();

  initConfetti();

  initStars();

  updateLabels();

});

switchCamBtn.addEventListener('click', ()=>{

  facingMode = (facingMode === 'user') ? 'environment' : 'user';

  startCamera();

});

toggleLinesCheckbox.addEventListener('change', e => { showLines = e.target.checked; });

toggleEffectsCheckbox.addEventListener('change', e => { showEffects = e.target.checked; });

// snapshot & record

snapshotBtn.addEventListener('click', ()=>{

  const a = document.createElement('a');

  a.download = `manicure_effect_${Date.now()}.png`;

  a.href = canvas.toDataURL('image/png');

  a.click();

  const div = document.createElement('div');

  div.innerHTML = `📸 <a href="${a.href}" download="${a.download}">Скачать снимок</a>`;

  downloads.prepend(div);

});

recordBtn.addEventListener('click', ()=>{

  if(recorder) return;

  const stream = canvas.captureStream(30);

  try{

    recorder = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'});

  } catch(e){

    recorder = new MediaRecorder(stream);

  }

  chunks = [];

  recorder.ondataavailable = e=>{ if(e.data.size) chunks.push(e.data); };

  recorder.onstop = ()=>{

    const blob = new Blob(chunks, {type:'video/webm'});

    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');

    a.href = url;

    a.download = `manicure_effect_video_${Date.now()}.webm`;

    a.textContent = '🎬 Скачать видео';

    const div = document.createElement('div');

    div.appendChild(a);

    downloads.prepend(div);

    recorder = null;

    stopBtn.disabled = true;

    recordBtn.disabled = false;

  };

  recorder.start();

  recordBtn.disabled = true;

  stopBtn.disabled = false;

});

stopBtn.addEventListener('click', ()=>{ if(recorder) recorder.stop(); });

function randomEffect(){

  const opts = ['glow','sparkle','orbit','burst','fire','lightning','rainbow','confetti','pulse','stars'];

  return opts[Math.floor(Math.random()*opts.length)];

}

// init

config.effect = 'glow';

initSparkles();

initConfetti();

initStars();

updateLabels();

startCamera();

</script>

</body>

</html><script></script></body></html>
